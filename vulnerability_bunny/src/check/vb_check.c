/*
 * pb_handlers.c
 *
 *      Author: john
 */

#include "vb_check.h"

#include "drreg.h"
#include "string.h"

#include "../vb_private.h"
#include "../policy/vb_taint_policy.h"
#include "../detection/vb_detect.h"

/*********************************************
 * Checks
 */

static void vb_insert_uaf_check(vb_context_t *vb_ctx, void *drcontext,
        instrlist_t *ilist, instr_t *where, vb_detection_func_t uaf_func,
        reg_id_t label_reg) {

    // Insert check for UAF
    if (vb_ctx->vuln_options & VB_EV_DETECT_UAF) {

        instr_t *check_next_label = INSTR_CREATE_label(drcontext);

        opnd_t live_opnd =
        OPND_CREATE_MEMPTR(label_reg, offsetof(vb_heap_ptr_t, is_live));
        ub_instrum_check_mem_null_false_case(drcontext, ilist, where,
        NULL, &live_opnd, check_next_label);

        dr_insert_clean_call(drcontext, ilist, where, uaf_func, false, 1,
                opnd_create_reg(label_reg));

        // UAF check jumps here if it f
        instrlist_meta_preinsert(ilist, where, check_next_label);
    }
}

static void vb_insert_hbo_boundary_check(void *drcontext, instrlist_t *ilist,
        instr_t *where, reg_id_t label_reg, reg_id_t addr_reg,
        instr_t *trigger_hbo_label) {

    instr_t *instr;

    opnd_t addr_opnd = opnd_create_reg(addr_reg);

    opnd_t low_opnd =
    OPND_CREATE_MEMPTR(label_reg, offsetof(vb_heap_ptr_t, root_addr));
    instr = INSTR_CREATE_cmp(drcontext, addr_opnd, low_opnd);
    instrlist_meta_preinsert(ilist, where, instr);

    instr = INSTR_CREATE_jcc(drcontext, OP_jb,
            opnd_create_instr(trigger_hbo_label));
    instrlist_meta_preinsert(ilist, where, instr);

    opnd_t high_opnd =
    OPND_CREATE_MEMPTR(label_reg, offsetof(vb_heap_ptr_t, end_addr));
    instr = INSTR_CREATE_cmp(drcontext, addr_opnd, high_opnd);
    instrlist_meta_preinsert(ilist, where, instr);

    instr = INSTR_CREATE_jcc(drcontext, OP_jnb,
            opnd_create_instr(trigger_hbo_label));
    instrlist_meta_preinsert(ilist, where, instr);
}

/**
 * TODO Reduce code via sub functions
 */

static void vb_insert_hbo_check(vb_context_t *vb_ctx, void *drcontext,
        instrlist_t *ilist, instr_t *where, bool is_inc,
        vb_detection_func_t hbo_func, reg_id_t label_reg, int size,
        reg_id_t scratch_reg, ub_opnd_access_t *addr_slot,
        reg_id_t length_reg) {

    // Insert check for HBO
    if (vb_ctx->vuln_options & VB_EV_DETECT_HBO) {

        instr_t *trigger_hbo_label = INSTR_CREATE_label(drcontext);
        instr_t *check_next_label = INSTR_CREATE_label(drcontext);

        // Calculate the max addr
        ib_insert_get_comp_opnd(drcontext, ilist, where, scratch_reg,
                addr_slot);
        opnd_t addr_opnd = opnd_create_reg(scratch_reg);
        ub_instrum_mov_ld_mem_opnd_to_reg(drcontext, ilist, where, &addr_opnd,
                scratch_reg);

        if (is_inc) {

            // Check beginning
            vb_insert_hbo_boundary_check(drcontext, ilist, where, label_reg,
                    scratch_reg, trigger_hbo_label);

            if (length_reg != DR_REG_NULL) {

                // Calculate rep end and decrement by 1!
                ub_instrum_lea_base_disp_index(drcontext, ilist, where,
                        scratch_reg, length_reg, -1, size, scratch_reg);

                vb_insert_hbo_boundary_check(drcontext, ilist, where, label_reg,
                        scratch_reg, trigger_hbo_label);

            } else {

                // TODO: NEED TO HANDLE STRLEN - COMMENTING OUT TILL THEN

//                // Increment by size and decrement by 1
//                ub_instrum_add_reg_immed(drcontext, ilist, where, scratch_reg,
//                        size - 1);
            }
        } else {

            if (length_reg != DR_REG_NULL) {

                // Calculate the end and check for hbo
                ub_instrum_add_reg_immed(drcontext, ilist, where, scratch_reg,
                        size - 1);
                vb_insert_hbo_boundary_check(drcontext, ilist, where, label_reg,
                        scratch_reg, trigger_hbo_label);

                // Since we are decrementing, get beginning
                ub_instrum_lea_base_disp_index(drcontext, ilist, where,
                        scratch_reg, length_reg, 1, size, scratch_reg);

                vb_insert_hbo_boundary_check(drcontext, ilist, where, label_reg,
                        scratch_reg, trigger_hbo_label);

            } else {

                // If we are only doing this once, we follow the standard way as inc.
                vb_insert_hbo_boundary_check(drcontext, ilist, where, label_reg,
                        scratch_reg, trigger_hbo_label);

                // TODO: NEED TO HANDLE STRLEN - COMMENTING OUT TILL THEN
                // DR Memory replaces functions with simpler versions. We can use these

//                ub_instrum_add_reg_immed(drcontext, ilist, where, scratch_reg,
//                        size - 1);
            }
        }


        ub_instrum_direct_jmp(drcontext, ilist, where, check_next_label);

        instrlist_meta_preinsert(ilist, where, trigger_hbo_label);

        // TRIGGER HBO!

        dr_insert_clean_call(drcontext, ilist, where, hbo_func, false, 1,
                opnd_create_reg(label_reg));

        instrlist_meta_preinsert(ilist, where, check_next_label);
    }
}

void vb_standard_check(vb_context_t *vb_ctx, void *drcontext,
        instrlist_t *ilist, instr_t *where, size_t opnd_size,
        ub_opnd_access_t *base_slot, ub_opnd_access_t *addr_slot,
        vb_detection_func_t uaf_func, vb_detection_func_t hbo_func,
        reg_id_t scratch_reg1, reg_id_t scratch_reg2) {

    instr_t *done_label = INSTR_CREATE_label(drcontext);

    // If taint analysis is off, don't perform check!
    tb_insert_is_analysis_on(drcontext, ilist, where, vb_ctx->taint_bunny,
            done_label);

    /* Get opnd */
    ib_insert_get_comp_opnd(drcontext, ilist, where, scratch_reg1, base_slot);

    /* Get label */
    tb_insert_get_reg_label(vb_ctx->taint_bunny, drcontext, ilist, where,
            scratch_reg2, scratch_reg1);

    ub_instrum_check_null_true_case(drcontext, ilist, where, scratch_reg1,
            done_label);

    // Insert to UAF check
    vb_insert_uaf_check(vb_ctx, drcontext, ilist, where, uaf_func,
            scratch_reg1);

    // Insert to HBO check
    vb_insert_hbo_check(vb_ctx, drcontext, ilist, where, true, hbo_func,
            scratch_reg1, opnd_size, scratch_reg2, addr_slot, DR_REG_NULL);

    instrlist_meta_preinsert(ilist, where, done_label);
}

/**************************************************************************
 * Rep Handlers
 *
 * For rep movs, we need to check both src and dst addresses. For rep stos
 * we just need to take the dst address.
 *
 * For HBO, we need to consider the count!
 */

static void vb_rep_addr_check_helper(vb_context_t *vb_ctx, void *drcontext,
        instrlist_t *ilist, instr_t *where, bool is_inc, size_t opnd_size,
        ub_opnd_access_t *base_slot, ub_opnd_access_t *addr_slot,
        vb_detection_func_t uaf_func, vb_detection_func_t hbo_func,
        reg_id_t length_reg, reg_id_t scratch_reg, reg_id_t scratch_reg2) {

    instr_t *done_label = INSTR_CREATE_label(drcontext);

    // If taint analysis is off, don't perform check!
    tb_insert_is_analysis_on(drcontext, ilist, where, vb_ctx->taint_bunny,
            done_label);

    /* Get opnd */
    ib_insert_get_comp_opnd(drcontext, ilist, where, scratch_reg, base_slot);

    /* Get label */
    tb_insert_get_reg_label(vb_ctx->taint_bunny, drcontext, ilist, where,
            scratch_reg2, scratch_reg);

    ub_instrum_check_null_true_case(drcontext, ilist, where, scratch_reg,
            done_label);

    // Insert to UAF check
    vb_insert_uaf_check(vb_ctx, drcontext, ilist, where, uaf_func, scratch_reg);

    // Insert to HBO check
    vb_insert_hbo_check(vb_ctx, drcontext, ilist, where, is_inc, hbo_func,
            scratch_reg, opnd_size, scratch_reg2, addr_slot, length_reg);

    instrlist_meta_preinsert(ilist, where, done_label);

}

void vb_rep_check(vb_context_t *vb_ctx, size_t inc_size, bool inc_dst,
        bool inc_src, ub_opnd_field_t cnt_field, void *drcontext,
        instrlist_t *ilist, instr_t *where, reg_id_t scratch_reg,
        reg_id_t scratch_reg2, reg_id_t scratch_reg3) {

    instr_t* done_label = INSTR_CREATE_label(drcontext);
    instr_t* dec_label = INSTR_CREATE_label(drcontext);

    tb_insert_is_analysis_on(drcontext, ilist, where, vb_ctx->taint_bunny,
            done_label);

    ib_insert_load_per_thread_data(drcontext, ilist, where, scratch_reg);

    ub_opnd_access_t length_slot;
    length_slot.opnd_field = cnt_field;
    length_slot.comp_field = UB_COMP_1;
    ib_insert_get_comp_conc_ex(drcontext, ilist, where, scratch_reg,
            scratch_reg3, 4, &length_slot, 0);

    opnd_t done_label_opnd = opnd_create_instr(done_label);
    opnd_t dec_label_entral_opnd = opnd_create_instr(dec_label);

    // Check if length is zero, and if so, jump to done label
    ub_instrum_check_null_true_case(drcontext, ilist, where, scratch_reg3,
            done_label);

    opnd_t eflags_opnd = ib_insert_get_flags_opnd_ex(scratch_reg);

    ub_eflag_insert_check_direction(drcontext, ilist, where, &eflags_opnd,
            &dec_label_entral_opnd, scratch_reg2);

    ub_opnd_access_t dst_base_slot;
    dst_base_slot.opnd_field = UB_DST_OPND_1;
    dst_base_slot.comp_field = UB_COMP_2;

    ub_opnd_access_t dst_addr_slot;
    dst_addr_slot.opnd_field = UB_DST_OPND_1;
    dst_addr_slot.comp_field = UB_COMP_1;

    ub_opnd_access_t src_base_slot;
    src_base_slot.opnd_field = UB_SRC_OPND_1;
    src_base_slot.comp_field = UB_COMP_2;

    ub_opnd_access_t src_addr_slot;
    src_addr_slot.opnd_field = UB_SRC_OPND_1;
    src_addr_slot.comp_field = UB_COMP_1;

// -------------------------  INCREMENT SECTION --------------------

    if (inc_src)
        vb_rep_addr_check_helper(vb_ctx, drcontext, ilist, where,
        true, inc_size, &src_base_slot, &src_addr_slot, vb_handle_uaf_1_src,
                vb_handle_hbo_1_src, scratch_reg3, scratch_reg, scratch_reg2);

    if (inc_dst)
        vb_rep_addr_check_helper(vb_ctx, drcontext, ilist, where,
        true, inc_size, &dst_base_slot, &dst_addr_slot, vb_handle_uaf_1_dst,
                vb_handle_hbo_1_dst, scratch_reg3, scratch_reg, scratch_reg2);

    ub_instrum_direct_jmp(drcontext, ilist, where, done_label);

// -------------------------  DECREMENT SECTION --------------------

    instrlist_meta_preinsert(ilist, where, dec_label);

    instr_t *instr = INSTR_CREATE_neg(drcontext, opnd_create_reg(scratch_reg3));
    instrlist_meta_preinsert(ilist, where, instr);

    if (inc_src)
        vb_rep_addr_check_helper(vb_ctx, drcontext, ilist, where,
        false, inc_size, &src_base_slot, &src_addr_slot, vb_handle_uaf_1_src,
                vb_handle_hbo_1_src, scratch_reg3, scratch_reg, scratch_reg2);

    if (inc_dst)
        vb_rep_addr_check_helper(vb_ctx, drcontext, ilist, where,
        false, inc_size, &dst_base_slot, &dst_addr_slot, vb_handle_uaf_1_dst,
                vb_handle_hbo_1_dst, scratch_reg3, scratch_reg, scratch_reg2);

    instrlist_meta_preinsert(ilist, where, done_label);
}

