/*
 * vb_spill.c
 *
 *      Author: john
 */

#include "vb_spill.h"

#include "drreg.h"
#include "string.h"
#include "../vb_private.h"
#include "../check/vb_check.h"

void vb_live_regs_init() {

    drreg_options_t ops;
    ops.struct_size = sizeof(ops);
    ops.conservative = false;
    ops.num_spill_slots = 4;

    // We do not want to add more slots to those already made
    // in previous drreg inits, but get the max.
    ops.do_not_sum_slots = true;

    // Initialise drreg
    if (drreg_init(&ops) != DRREG_SUCCESS)
        DR_ASSERT(false);
}

void vb_live_regs_destroy() {

    drreg_exit();
}

void vb_spill_two_regs(void *drcontext, instrlist_t *ilist, instr_t *where,
        void *user_data, void **spilling_data_opaque) {

    drvector_t allowed;
    drreg_init_and_fill_vector(&allowed, false);
    drreg_set_vector_entry(&allowed, vb_reg1, true);
    drreg_set_vector_entry(&allowed, vb_reg2, true);

    reg_id_t reg;
    if (drreg_reserve_register(drcontext, ilist, where, &allowed, &(reg))
            != DRREG_SUCCESS
            || drreg_reserve_register(drcontext, ilist, where, &allowed, &(reg))
                    != DRREG_SUCCESS
            || drreg_reserve_aflags(drcontext, ilist, where) != DRREG_SUCCESS) {

        DR_ASSERT(false); /* cannot recover */
    }

    drvector_delete(&allowed);
    *spilling_data_opaque = NULL;
}

void vb_restore_two_regs(void *drcontext, instrlist_t *ilist, instr_t *where,
        void *user_data, void *spilling_data_opaque) {

    if (drreg_unreserve_register(drcontext, ilist, where, vb_reg1)
            != DRREG_SUCCESS)
        DR_ASSERT(false);

    if (drreg_unreserve_register(drcontext, ilist, where, vb_reg2)
            != DRREG_SUCCESS)
        DR_ASSERT(false);

    drreg_unreserve_aflags(drcontext, ilist, where);
}

void vb_spill_three_regs(void *drcontext, instrlist_t *ilist, instr_t *where,
        void *user_data, void **spilling_data_opaque) {

    vb_spill_two_regs(drcontext, ilist, where, user_data, spilling_data_opaque);

    drvector_t allowed;
    drreg_init_and_fill_vector(&allowed, false);
    drreg_set_vector_entry(&allowed, vb_reg3, true);

    reg_id_t reg;
    if (drreg_reserve_register(drcontext, ilist, where, &allowed, &(reg))
            != DRREG_SUCCESS) {

        DR_ASSERT(false); /* cannot recover */
    }

    drvector_delete(&allowed);
    *spilling_data_opaque = NULL;
}

void vb_restore_three_regs(void *drcontext, instrlist_t *ilist, instr_t *where,
        void *user_data, void *spilling_data_opaque) {

    if (drreg_unreserve_register(drcontext, ilist, where, vb_reg3)
            != DRREG_SUCCESS)
        DR_ASSERT(false);

    vb_restore_two_regs(drcontext, ilist, where, user_data,
            spilling_data_opaque);
}
