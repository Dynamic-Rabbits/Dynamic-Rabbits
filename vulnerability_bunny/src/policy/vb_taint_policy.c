/*
 * vb_taint_policy.c
 *
 *      Author: john
 */

#include "vb_taint_policy.h"
#include "../vb_private.h"

extern vb_context_t *vb_ctx;

void vb_tl_new_ref(void *taint_label) {

    if (!taint_label)
        return;

    ub_sl_try_and_lock(&(vb_ctx->spin_lock));

    vb_heap_ptr_t *uaf_tl = (vb_heap_ptr_t *) taint_label;
    uaf_tl->count++;

    ub_sl_unlock(&(vb_ctx->spin_lock));
}

void vb_tl_delete_ref(void *taint_label) {

    if (!taint_label)
        return;

    ub_sl_try_and_lock(&(vb_ctx->spin_lock));

    vb_heap_ptr_t *uaf_tl = (vb_heap_ptr_t *) taint_label;
    DR_ASSERT(uaf_tl->count > 0);

    uaf_tl->count--;

    // if the counter has reached 0, we perform a deallocation.
    if (uaf_tl->count <= 0){
        ub_deallocate(vb_ctx->allocator, uaf_tl);
    }

    ub_sl_unlock(&(vb_ctx->spin_lock));
}
