/*
 * uaf_taint_policy.c
 *
 *      Author: john
 */

#include "vb_raw_taint_policy.h"

#include "dr_defines.h"
#include "drext.h"
#include "dr_api.h"
#include "drreg.h"

#include "../vb_private.h"

/*********************************************************************
 * Prototypes
 */

static void insert_raw_spill_additional_regs(void *drcontext,
        instrlist_t *ilist, instr_t *where, bool is_inline);
static void insert_raw_restore_additional_regs(void *drcontext,
        instrlist_t *ilist, instr_t *where, bool is_inline);
static void insert_new_ref_tl_func(void *drcontext, instrlist_t *ilist,
        instr_t *where, reg_id_t taint_label, reg_id_t scratch_reg);
static void insert_delete_ref_tl_func(void *drcontext, instrlist_t *ilist,
        instr_t *where, reg_id_t taint_label, reg_id_t scratch_reg);
static void insert_meet(void *drcontext, instrlist_t *ilist, instr_t *where,
        app_pc app_instr, reg_id_t meet_reg, opnd_t *label_lowest_opnd,
        opnd_t *src1_opnd, reg_id_t scratch_reg);
static void insert_propogate_func_1dst_1src(void *drcontext, instrlist_t *ilist,
        instr_t *where, app_pc app_instr, reg_id_t dst_reg, opnd_t *src1_opnd,
        reg_id_t scratch_reg);
static void insert_propogate_func_1dst_2src(void *drcontext, instrlist_t *ilist,
        instr_t *where, app_pc app_instr, reg_id_t dst_reg, opnd_t *src1_opnd,
        opnd_t *src2_opnd, reg_id_t scratch_reg);

/*********************************************************************
 * Global variables
 */

extern vb_context_t *vb_ctx;
static reg_id_t additional_spill_reg_xax = DR_REG_XAX;

/*********************************************************************
 * Implementation
 */

void vb_tl_raw_initialise_taint_policy(tb_raw_taint_policy_t *taint_policy) {

    drreg_options_t ops = { sizeof(ops), 2, false, NULL, false };
    if (drreg_init(&ops) != DRREG_SUCCESS)
        DR_ASSERT(false);

    memset(taint_policy, 0, sizeof(tb_raw_taint_policy_t));

    taint_policy->new_ref_tl_func = vb_tl_new_ref;
    taint_policy->insert_raw_new_ref_tl = insert_new_ref_tl_func;

    taint_policy->delete_ref_tl_func = vb_tl_delete_ref;
    taint_policy->insert_raw_delete_ref_tl = insert_delete_ref_tl_func;

    taint_policy->insert_raw_propogate_1dst_1src =
            insert_propogate_func_1dst_1src;
    taint_policy->insert_raw_propogate_1dst_2src =
            insert_propogate_func_1dst_2src;
    taint_policy->insert_raw_meet = insert_meet;

    taint_policy->insert_raw_spill_additional_regs =
            insert_raw_spill_additional_regs;
    taint_policy->insert_raw_restore_additional_regs =
            insert_raw_restore_additional_regs;

    /** We will handle this externally **/
    taint_policy->get_default_label = NULL;
}

void vb_tl_raw_destroy_taint_policy() {

    drreg_exit();
}

static void insert_raw_spill_additional_regs(void *drcontext,
        instrlist_t *ilist, instr_t *where, bool is_inline) {

    drvector_t allowed;
    drreg_init_and_fill_vector(&allowed, false);
    drreg_set_vector_entry(&allowed, DR_REG_XAX, true);
    if (drreg_reserve_register(drcontext, ilist, where, &allowed,
            &additional_spill_reg_xax) != DRREG_SUCCESS)
        DR_ASSERT(false); /* cannot recover */

    DR_ASSERT(additional_spill_reg_xax == DR_REG_XAX);
    drvector_delete(&allowed);
}

static void insert_raw_restore_additional_regs(void *drcontext,
        instrlist_t *ilist, instr_t *where, bool is_inline) {

    if (drreg_unreserve_register(drcontext, ilist, where,
            additional_spill_reg_xax) != DRREG_SUCCESS)
        DR_ASSERT(false);
}

static void insert_new_ref_tl_func(void *drcontext, instrlist_t *ilist,
        instr_t *where, reg_id_t taint_label, reg_id_t scratch_reg) {

    ub_sl_insert_try_and_lock(drcontext, ilist, where, additional_spill_reg_xax,
            scratch_reg, &(vb_ctx->spin_lock));

    // Increment reference counter.
    ub_instrum_inc_mem(drcontext, ilist, where, taint_label,
            offsetof(vb_heap_ptr_t, count));

    ub_sl_insert_unlock(drcontext, ilist, where, &(vb_ctx->spin_lock));
}

static void insert_delete_ref_tl_func(void *drcontext, instrlist_t *ilist,
        instr_t *where, reg_id_t taint_label, reg_id_t scratch_reg) {

    ub_sl_insert_try_and_lock(drcontext, ilist, where, additional_spill_reg_xax,
            scratch_reg, &(vb_ctx->spin_lock));

    ub_instrum_dec_mem(drcontext, ilist, where, taint_label,
            offsetof(vb_heap_ptr_t, count));

    instr_t *not_zero_label = INSTR_CREATE_label(drcontext);

    instr_t *jmp_instr = INSTR_CREATE_jcc(drcontext, OP_jnz,
            opnd_create_instr(not_zero_label));
    instrlist_meta_preinsert(ilist, where, jmp_instr);

    // We have reached the zero count. We need to deallocate!
    ub_insert_dealloation(vb_ctx->allocator, drcontext, ilist, where,
            taint_label, additional_spill_reg_xax, scratch_reg);

    instrlist_meta_preinsert(ilist, where, not_zero_label);

    ub_sl_insert_unlock(drcontext, ilist, where, &(vb_ctx->spin_lock));
}

static void insert_meet(void *drcontext, instrlist_t *ilist, instr_t *where,
        app_pc app_instr, reg_id_t meet_reg, opnd_t *label_lowest_opnd,
        opnd_t *src1_opnd, reg_id_t scratch_reg) {

    instr_t *done = INSTR_CREATE_label(drcontext);
    instr_t *src1_is_dangling = INSTR_CREATE_label(drcontext);

    // Load the label
    opnd_t dst_opnd = opnd_create_reg(scratch_reg);
    instr_t * instr = INSTR_CREATE_mov_ld(drcontext, dst_opnd, *src1_opnd);
    instr_set_translation(instr, app_instr);
    instrlist_meta_preinsert(ilist, where, instr);

    ub_instrum_check_null_true_case(drcontext, ilist, where, scratch_reg, done);

    // Check if ptr is dangling
    opnd_t live_opnd =
    OPND_CREATE_MEMPTR(scratch_reg, offsetof(vb_heap_ptr_t, is_live));
    ub_instrum_check_mem_null_true_case(drcontext, ilist, where, app_instr, &live_opnd,
            src1_is_dangling);

    ub_instrum_check_null_false_case(drcontext, ilist, where, meet_reg, done);

    instrlist_meta_preinsert(ilist, where, src1_is_dangling);
    ub_instrum_mov_st_reg_to_reg(drcontext, ilist, where, scratch_reg,
            meet_reg);

    instrlist_meta_preinsert(ilist, where, done);
}


void cc1(vb_heap_ptr_t *ptr){


    if (ptr)
    dr_fprintf(STDERR, "DST Tainted %p\n", ptr->root_addr);
    else
        dr_fprintf(STDERR, "DSt The root is NULL!\n");
}

static void insert_propogate_func_1dst_1src(void *drcontext, instrlist_t *ilist,
        instr_t *where, app_pc app_instr, reg_id_t dst_reg, opnd_t *src1_opnd,
        reg_id_t scratch_reg) {

    opnd_t dst_opnd = opnd_create_reg(dst_reg);
    instr_t * instr = INSTR_CREATE_mov_ld(drcontext, dst_opnd, *src1_opnd);
    instr_set_translation(instr, app_instr);
    instrlist_meta_preinsert(ilist, where, instr);

//    dr_insert_clean_call(drcontext, ilist, where,cc1, false, 1, dst_opnd);
}

static void insert_propogate_func_1dst_2src(void *drcontext, instrlist_t *ilist,
        instr_t *where, app_pc app_instr, reg_id_t dst_reg, opnd_t *src1_opnd,
        opnd_t *src2_opnd, reg_id_t scratch_reg) {

    instr_t *src1_not_null_label = INSTR_CREATE_label(drcontext);
    instr_t *src1_src2_not_null_label = INSTR_CREATE_label(drcontext);
    instr_t *done_label = INSTR_CREATE_label(drcontext);

    ub_instrum_check_mem_null_false_case(drcontext, ilist, where, app_instr, src1_opnd,
            src1_not_null_label);

    opnd_t dst_opnd = opnd_create_reg(dst_reg);
    instr_t * instr = INSTR_CREATE_mov_ld(drcontext, dst_opnd, *src2_opnd);
    instr_set_translation(instr, app_instr);
    instrlist_meta_preinsert(ilist, where, instr);

    ub_instrum_direct_jmp(drcontext, ilist, where, done_label);

    instrlist_meta_preinsert(ilist, where, src1_not_null_label);

    ub_instrum_check_mem_null_false_case(drcontext, ilist, where, app_instr, src2_opnd,
            src1_src2_not_null_label);

    dst_opnd = opnd_create_reg(dst_reg);
    instr = INSTR_CREATE_mov_ld(drcontext, dst_opnd, *src1_opnd);
    instr_set_translation(instr, app_instr);
    instrlist_meta_preinsert(ilist, where, instr);

    ub_instrum_direct_jmp(drcontext, ilist, where, done_label);

    instrlist_meta_preinsert(ilist, where, src1_src2_not_null_label);
    ub_instrum_clear_reg(drcontext, ilist, where, dst_reg);

    instrlist_meta_preinsert(ilist, where, done_label);

//    dr_insert_clean_call(drcontext, ilist, where,cc1, false, 1, dst_opnd);
}
