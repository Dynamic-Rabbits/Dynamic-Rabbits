#include "vulnerability_bunny.h"
#include "vb_private.h"
#include "policy/vb_cc_taint_policy.h"
#include "policy/vb_raw_taint_policy.h"
#include "check/vb_check.h"
#include "instrumentation/vb_instrum_register.h"

#include "instrumentation/vb_spill.h"

#include <string.h>
#include <stddef.h>

/****************************************************************
 * Prototypes
 */

static void vb_pre_heap_pointer(ub_ev_alloc_data_t *alloc_data);
static void vb_pre_dangle_pointer(ub_ev_dealloc_data_t *dealloc_data);
static void vb_taint_heap_pointer(ub_ev_alloc_data_t *alloc_data);
static void vb_dangle_heap_pointers(ub_ev_dealloc_data_t *dealloc_data);
static void vb_pre_realoc(ub_ev_realloc_data_t *realloc_data);
static void vb_post_realloc(ub_ev_realloc_data_t *realloc_data);

/********************************************************************
 * Implementation
 */

static bool use_cc_imp = true;

vb_context_t *vb_ctx = NULL;

DR_EXPORT void vb_init(client_id_t client_id, vb_handle_vuln_func_t vuln_func,
        VB_EV_VULN_OPT_t vuln_options, void *user_data) {

    DR_ASSERT(vuln_func);
    DR_ASSERT(ib_is_initialised());

    if (vb_ctx) {
        vb_ctx->ref_count++;
        return;

    } else {

        vb_live_regs_init();

        vb_ctx = dr_global_alloc(sizeof(vb_context_t));
        vb_ctx->ref_count = 1;
        vb_ctx->vun_func = vuln_func;
        vb_ctx->user_data = user_data;
        vb_ctx->vuln_options = vuln_options;
        vb_ctx->spin_lock = 0;
        vb_ctx->allocator = ub_create_fixed_allocator(5, sizeof(vb_heap_ptr_t));
        vb_ctx->tool_id = ib_register_instrum_tool();
        vb_ctx->heap_to_ptr_mp = ub_intptr_hashmap_create_map();

        tb_options_t te_options;
        te_options.enable_fp = true;
        te_options.enable_inline = false;
        te_options.enable_taint_off = true; /* Help prevent false positives*/

        if (!use_cc_imp) {
            tb_raw_taint_policy_t ptr_policy;
            vb_tl_raw_initialise_taint_policy(&ptr_policy);
            vb_ctx->taint_bunny = tb_raw_init(client_id, IB_OPT_BARE,
                    &te_options,
                    NULL, &ptr_policy);
        } else {
            te_options.enable_fp = false;
            tb_cc_taint_policy_t ptr_policy;
            vb_tl_cc_initialise_taint_policy(&ptr_policy);

            vb_ctx->taint_bunny = tb_cc_init(client_id, IB_OPT_BARE,
                    &te_options,
                    NULL, &ptr_policy);
        }

        vb_register_checks(vb_ctx);

        tb_register_hooks(vb_ctx->taint_bunny);

        ub_ev_heap_alloc_init_ctx(vb_pre_heap_pointer, vb_taint_heap_pointer);
        ub_ev_heap_dealloc_init_ctx(vb_pre_dangle_pointer,
                vb_dangle_heap_pointers);
        ub_ev_heap_realloc_init_ctx(vb_pre_realoc, vb_post_realloc);
    }
}

DR_EXPORT void vb_exit() {

    DR_ASSERT(vb_ctx);

    vb_ctx->ref_count--;

    if (vb_ctx->ref_count == 0) {

        // We reached a ref count of 0. Perform deallocation!
        ub_ev_heap_alloc_destroy_ctx();
        ub_ev_heap_dealloc_destroy_ctx();
        ub_ev_heap_realloc_destroy_ctx();

        ub_intptr_hashmap_destroy_map(vb_ctx->heap_to_ptr_mp, vb_tl_delete_ref);
        tb_raw_exit(vb_ctx->taint_bunny);

        if (!use_cc_imp)
            vb_tl_raw_destroy_taint_policy();

        ib_unregister_instrum_tool(vb_ctx->tool_id);
        ub_destroy_fixed_allocator(vb_ctx->allocator);
        dr_global_free(vb_ctx, sizeof(vb_context_t));

        vb_live_regs_destroy();

        vb_ctx = NULL;
    }
}

/**
 * No taint anaylsis upon entry to heap functions!
 */

static void vb_pre_heap_pointer(ub_ev_alloc_data_t *alloc_data) {

    tb_turn_off_analysis(vb_ctx->taint_bunny, dr_get_current_drcontext());
}

static void vb_pre_dangle_pointer(ub_ev_dealloc_data_t *dealloc_data) {

    tb_turn_off_analysis(vb_ctx->taint_bunny, dr_get_current_drcontext());
}

static void vb_pre_realoc(ub_ev_realloc_data_t *realloc_data) {

    tb_turn_off_analysis(vb_ctx->taint_bunny, dr_get_current_drcontext());
}

static vb_heap_ptr_t * init_live_heap_ptr(uintptr_t root, uintptr_t creation_pc,
        size_t size, uintptr_t ret_pc) {

    ub_intptr_hashmap_lock(vb_ctx->heap_to_ptr_mp);

    vb_heap_ptr_t *heap_ptr_tl = (vb_heap_ptr_t *) ub_allocate(
            vb_ctx->allocator);

    heap_ptr_tl->is_live = true;
    heap_ptr_tl->count = 0;
    heap_ptr_tl->root_addr = root;
    heap_ptr_tl->end_addr = root + (intptr_t) size;
    heap_ptr_tl->creation_pc = creation_pc;
    heap_ptr_tl->ret_creation_pc = ret_pc;
    heap_ptr_tl->object_size = size;
    heap_ptr_tl->alloc_counter = 1;

    ub_key_value_pair_t key_value_pair;
    key_value_pair.key = root;
    key_value_pair.value = heap_ptr_tl;

    /* Include reference due to the labels entry to the hashmap */
    vb_tl_new_ref(heap_ptr_tl);

    vb_heap_ptr_t *old_tl = (vb_heap_ptr_t *) ub_intptr_hashmap_insert_entry(
            vb_ctx->heap_to_ptr_mp, &key_value_pair);

    if (old_tl) {
        /* We are early. Another thread might have deallocated this root elem,
         * but has not yet had its post dealloc called.
         *
         * We can allievate this issue further, when we extend this to replace
         * routines similar to DR Memory.
         */

        DR_ASSERT(old_tl->is_live);
        old_tl->is_live = false;
        old_tl->dangling_pc = 0;
        old_tl->ret_dangle_pc = 0;
        heap_ptr_tl->alloc_counter += old_tl->alloc_counter;

        vb_tl_delete_ref(old_tl);
    }

    ub_intptr_hashmap_unlock(vb_ctx->heap_to_ptr_mp);

    return heap_ptr_tl;
}

static void init_dangle_heap_ptr(uintptr_t root, uintptr_t dangling_pc,
        uintptr_t ret_pc) {

    ub_intptr_hashmap_lock(vb_ctx->heap_to_ptr_mp);

    vb_heap_ptr_t *heap_ptr_tl =
            (vb_heap_ptr_t *) ub_intptr_hashmap_lookup_entry(
                    vb_ctx->heap_to_ptr_mp, root);

    if (!heap_ptr_tl) {
        dr_fprintf(STDERR, "Warning: No mapped dealloc ptr: %p\n", root);
        ub_intptr_hashmap_unlock(vb_ctx->heap_to_ptr_mp);
        return;
    }

    heap_ptr_tl->alloc_counter--;
    DR_ASSERT(heap_ptr_tl->alloc_counter >= 0);
    if (heap_ptr_tl->alloc_counter != 0) {

        ub_intptr_hashmap_unlock(vb_ctx->heap_to_ptr_mp);
        return;
    }

    // Otherwise we have a double free or perhaps a realloc (but latter should be unlikely).
    DR_ASSERT(heap_ptr_tl->is_live);

    ub_intptr_hashmap_remove_entry(vb_ctx->heap_to_ptr_mp, root);

    heap_ptr_tl->is_live = false;
    heap_ptr_tl->dangling_pc = dangling_pc;
    heap_ptr_tl->ret_dangle_pc = ret_pc;

    vb_tl_delete_ref(heap_ptr_tl);

    ub_intptr_hashmap_unlock(vb_ctx->heap_to_ptr_mp);
}

/**
 *  Taints heap pointer. This function is called upon the call of a heap allocation
 *  function
 */
static void vb_taint_heap_pointer(ub_ev_alloc_data_t *alloc_data) {

    void *drcontext = dr_get_current_drcontext();

    tb_turn_on_analysis(vb_ctx->taint_bunny, drcontext);

    if (!alloc_data->addr)
        return;

    vb_heap_ptr_t *heap_ptr_tl = init_live_heap_ptr(
            (uintptr_t) alloc_data->addr, (uintptr_t) alloc_data->pc,
            alloc_data->size, (uintptr_t) alloc_data->return_pc);

    tb_taint_reg(vb_ctx->taint_bunny, drcontext, DR_REG_XAX, heap_ptr_tl);
}

/**
 *  Called upon deallocation so that pointers are dangled.
 */
static void vb_dangle_heap_pointers(ub_ev_dealloc_data_t *dealloc_data) {

    void *drcontext = dr_get_current_drcontext();

    tb_turn_on_analysis(vb_ctx->taint_bunny, dr_get_current_drcontext());

    if (dealloc_data->addr == NULL)
        return;

    init_dangle_heap_ptr((uintptr_t) dealloc_data->addr,
            (uintptr_t) dealloc_data->pc, (uintptr_t) dealloc_data->return_pc);
}

static void vb_post_realloc(ub_ev_realloc_data_t *realloc_data) {

    void *drcontext = dr_get_current_drcontext();

    tb_turn_on_analysis(vb_ctx->taint_bunny, drcontext);

    /* If NULL is returned, do nothing  */
    if (realloc_data->addr == NULL) {

        tb_untaint_reg(vb_ctx->taint_bunny, drcontext, DR_REG_XAX);

    } else if ((uintptr_t) realloc_data->addr
            == (uintptr_t) realloc_data->passed_addr) {

        ub_intptr_hashmap_lock(vb_ctx->heap_to_ptr_mp);

        vb_heap_ptr_t *heap_ptr_tl =
                (vb_heap_ptr_t *) ub_intptr_hashmap_lookup_entry(
                        vb_ctx->heap_to_ptr_mp, (uintptr_t) realloc_data->addr);

        DR_ASSERT(heap_ptr_tl);
        DR_ASSERT(heap_ptr_tl->is_live);
        DR_ASSERT(heap_ptr_tl->root_addr == (uintptr_t ) realloc_data->addr);

        /* Simply change size. HBO will detect out of bounds pointers. */
        heap_ptr_tl->object_size = realloc_data->size;
        heap_ptr_tl->end_addr = ((uintptr_t) realloc_data->addr)
                + (intptr_t) realloc_data->size;

        ub_intptr_hashmap_unlock(vb_ctx->heap_to_ptr_mp);

        tb_taint_reg(vb_ctx->taint_bunny, drcontext, DR_REG_XAX, heap_ptr_tl);

    } else {

        // If the return addr is null, keep the existing block untouched!
        if (realloc_data->passed_addr != NULL) {
            init_dangle_heap_ptr((uintptr_t) realloc_data->passed_addr,
                    (uintptr_t) realloc_data->pc,
                    (uintptr_t) realloc_data->return_pc);
        }

        if (realloc_data->addr != NULL) {
            DR_ASSERT(realloc_data->addr != realloc_data->passed_addr);

            vb_heap_ptr_t *heap_ptr_tl = init_live_heap_ptr(
                    (uintptr_t) realloc_data->addr,
                    (uintptr_t) realloc_data->pc, realloc_data->size,
                    (uintptr_t) realloc_data->return_pc);

            tb_taint_reg(vb_ctx->taint_bunny, drcontext, DR_REG_XAX,
                    heap_ptr_tl);
        }
    }
}

/*****************************************************************************
 * Taint label getters
 */

DR_EXPORT uintptr_t vb_get_root_addr(void *vb_heap_ptr_opaque) {

    DR_ASSERT(vb_ctx);

    vb_heap_ptr_t *vb_heap_ptr = (vb_heap_ptr_t *) vb_heap_ptr_opaque;
    return vb_heap_ptr->root_addr;
}

DR_EXPORT uintptr_t vb_get_end(void *vb_heap_ptr_opaque) {

    DR_ASSERT(vb_ctx);

    vb_heap_ptr_t *vb_heap_ptr = (vb_heap_ptr_t *) vb_heap_ptr_opaque;
    return vb_heap_ptr->end_addr;
}

DR_EXPORT app_pc vb_get_creation_ret_pc(void *vb_heap_ptr_opaque) {

    DR_ASSERT(vb_ctx);

    vb_heap_ptr_t *vb_heap_ptr = (vb_heap_ptr_t *) vb_heap_ptr_opaque;
    return (app_pc) vb_heap_ptr->ret_creation_pc;
}

DR_EXPORT app_pc vb_get_dangle_ret_pc(void *vb_heap_ptr_opaque) {

    DR_ASSERT(vb_ctx);

    vb_heap_ptr_t *vb_heap_ptr = (vb_heap_ptr_t *) vb_heap_ptr_opaque;
    return (app_pc) vb_heap_ptr->ret_dangle_pc;
}

DR_EXPORT app_pc vb_get_creation_pc(void *vb_heap_ptr_opaque) {

    DR_ASSERT(vb_ctx);

    vb_heap_ptr_t *vb_heap_ptr = (vb_heap_ptr_t *) vb_heap_ptr_opaque;
    return (app_pc) vb_heap_ptr->creation_pc;
}

DR_EXPORT app_pc vb_get_dangling_pc(void *vb_heap_ptr_opaque) {

    DR_ASSERT(vb_ctx);

    vb_heap_ptr_t *vb_heap_ptr = (vb_heap_ptr_t *) vb_heap_ptr_opaque;
    return (app_pc) vb_heap_ptr->dangling_pc;
}

DR_EXPORT bool vb_is_live(void *vb_heap_ptr_opaque) {

    DR_ASSERT(vb_ctx);

    vb_heap_ptr_t *vb_heap_ptr = (vb_heap_ptr_t *) vb_heap_ptr_opaque;
    return vb_heap_ptr->is_live;
}

DR_EXPORT size_t vb_get_object_size(void *vb_heap_ptr_opaque) {

    DR_ASSERT(vb_ctx);

    vb_heap_ptr_t *vb_heap_ptr = (vb_heap_ptr_t *) vb_heap_ptr_opaque;
    return vb_heap_ptr->object_size;
}

DR_EXPORT void *vb_get_taint_bunny() {

    DR_ASSERT(vb_ctx);

    return vb_ctx->taint_bunny;
}

