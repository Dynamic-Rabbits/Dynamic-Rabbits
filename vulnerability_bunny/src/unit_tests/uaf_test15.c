/*
 * uaf_test15.c
 *
 *      Author: john
 */

#include <wchar.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

void printLine(const char * line)

{

	if (line != NULL)

	{

		printf("%s\n", line);

	}

}

static char * helperBad(char * aString)

{

    size_t i = 0;

    size_t j;

    char * reversedString = NULL;

    if (aString != NULL)

    {

        i = strlen(aString);

        reversedString = (char *) malloc(i+1);

        if (reversedString == NULL) {exit(-1);}
        for (j = 0; j < i; j++)

        {

            reversedString[j] = aString[i-j-1];

        }

        reversedString[i] = '\0';

        /* FLAW: Freeing a memory block and then returning a pointer to the freed memory */

        free(reversedString);

        return reversedString;

    }

    else

    {

        return NULL;

    }

}


/* The two variables below are declared "const", so a tool should

   be able to identify that reads of these will always return their

   initialized values. */

static const int STATIC_CONST_TRUE = 1; /* true */



void CWE416_Use_After_Free__return_freed_ptr_04_bad()

{

    if(STATIC_CONST_TRUE)

    {

        {

            /* Call the bad helper function */

            char * reversedString = helperBad("BadSink");

            printLine(reversedString);

            /* free(reversedString);

             * This call to free() was removed because we want the tool to detect the use after free,

             * but we don't want that function to be free(). Essentially we want to avoid a double free

             */

        }

    }

}


int main(int argc, char * argv[])

{

    printLine("Calling bad()...");

    CWE416_Use_After_Free__return_freed_ptr_04_bad();

    printLine("Finished bad()");

    return 0;

}

