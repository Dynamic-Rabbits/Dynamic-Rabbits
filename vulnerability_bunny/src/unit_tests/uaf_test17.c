/*
 * uaf_test17.c
 *
 *      Author: john
 */


#include <stdio.h>
#include <stdlib.h>
#include <string.h>

void printLine(const char * line)

{

	if (line != NULL)

	{

		printf("%s\n", line);

	}

}

static char * helperBad(char * aString)

{

    size_t i = 0;

    size_t j;

    char * reversedString = NULL;

    if (aString != NULL)

    {

        i = strlen(aString);

        reversedString = (char *) malloc(i+1);

        if (reversedString == NULL) {exit(-1);}
        for (j = 0; j < i; j++)

        {

            reversedString[j] = aString[i-j-1];

        }

        reversedString[i] = '\0';

        /* FLAW: Freeing a memory block and then returning a pointer to the freed memory */

        free(reversedString);

        return reversedString;

    }

    else

    {

        return NULL;

    }

}


void CWE416_Use_After_Free__return_freed_ptr_15_bad()

{

    switch(6)

    {

    case 6:

    {

        /* Call the bad helper function */

        char * reversedString = helperBad("BadSink");

        printLine(reversedString);

        /* free(reversedString);

         * This call to free() was removed because we want the tool to detect the use after free,

         * but we don't want that function to be free(). Essentially we want to avoid a double free

         */

    }

    break;

    default:

        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */

        printLine("Benign, fixed string");

        break;

    }

}


int main(int argc, char * argv[])

{

    printLine("Calling bad()...");

    CWE416_Use_After_Free__return_freed_ptr_15_bad();

    printLine("Finished bad()");

    return 0;
}
